package chat

import (
	"time"

	"github.com/google/uuid"

	"bytechat/internal/database"
)

// ChatMessageData holds data for rendering a single chat message.
type ChatMessageData struct {
	Text          string     `json:"text"`
	Sender        SenderInfo `json:"sender"`
	Timestamp     time.Time  `json:"timestamp"`
	IsCurrentUser bool       `json:"isCurrentUser"`
}

// SenderInfo holds minimal sender details.
type SenderInfo struct {
	ID        uuid.UUID `json:"id"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
}

// ChatPageData holds necessary data for rendering the chat page.
type ChatPageData struct {
	RoomID          uuid.UUID
	RoomName        string
	InitialMessages []database.ListMessagesByRoomRow
	CurrentUserID   uuid.UUID
}

// templ ChatMessage renders a single chat message using templ standard conditional classes.
templ ChatMessage(data ChatMessageData) {
	<div
		class={ templ.Classes(
			"p-2",
			"rounded-lg",
			"mb-2",
			templ.KV("bg-blue-100", data.IsCurrentUser),
			templ.KV("self-end", data.IsCurrentUser),
			templ.KV("bg-gray-200", !data.IsCurrentUser),
			templ.KV("self-start", !data.IsCurrentUser),
		) }
		style="max-width: 75%;"
		data-sender-id={ data.Sender.ID.String() }
	>
		if !data.IsCurrentUser {
			<div class="text-xs font-semibold text-gray-600 sender-name">{ data.Sender.FirstName } { data.Sender.LastName }</div>
		}
		<p class="text-sm text-gray-800">{ data.Text }</p>
		<div class="text-xs text-gray-500 text-right">{ data.Timestamp.Format("15:04") }</div>
	</div>
}

// templ ChatPage renders the main chat page.
templ ChatPage(data ChatPageData) {
	<section
		class="flex flex-col h-[calc(100vh-5rem)] bg-white rounded-lg shadow"
		hx-ext="ws"
		ws-connect={ "/chat/ws/" + data.RoomID.String() }
		hx-swap="beforeend"
		hx-target="#chat-messages"
	>
		<header class="p-4 border-b border-gray-200">
			<h2 class="text-lg font-semibold">{ data.RoomName }</h2>
			<span id="currentUserInfo" data-user-id={ data.CurrentUserID.String() } class="hidden"></span>
		</header>
		<div id="chat-messages" class="flex-1 overflow-y-auto p-4 space-y-2 flex flex-col">
			for _, msg := range data.InitialMessages {
				@ChatMessage(ChatMessageData{
					Text: msg.Text.String,
					Sender: SenderInfo{
						ID:        msg.UserID,
						FirstName: msg.FirstName,
						LastName:  msg.LastName,
					},
					Timestamp:     msg.CreatedAt.Time,
					IsCurrentUser: msg.UserID == data.CurrentUserID,
				})
			}
			<div id="message-bottom"></div>
		</div>
		<form
			id="chat-form"
			class="p-4 border-t border-gray-200"
			ws-send
		>
			<div class="flex items-center">
				<input
					id="message-input"
					type="text"
					name="text"
					placeholder="Type your message..."
					required
					class="flex-1 border border-gray-300 rounded-l-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
					autocomplete="off"
				/>
				<button type="submit" class="bg-blue-600 text-white px-4 py-2 rounded-r-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
					Send
				</button>
			</div>
		</form>
		<script>
         (function() {
             const chatMessagesDiv = document.getElementById('chat-messages');
             const messageBottomDiv = document.getElementById('message-bottom');
             const chatForm = document.getElementById('chat-form');
             const messageInput = document.getElementById('message-input');
             const currentUserInfo = document.getElementById('currentUserInfo');
             const currentUserID = currentUserInfo ? currentUserInfo.getAttribute('data-user-id') : null;

             function scrollToBottom() {
                 const scrollThreshold = 50; // Pixels from bottom
                 const isScrolledNearBottom = chatMessagesDiv.scrollHeight - chatMessagesDiv.scrollTop - chatMessagesDiv.clientHeight < scrollThreshold;

                 if (messageBottomDiv && isScrolledNearBottom) {
                    messageBottomDiv.scrollIntoView({ behavior: "smooth", block: "end" });
                 } else if (chatMessagesDiv && isScrolledNearBottom) {
                    chatMessagesDiv.scrollTo({ top: chatMessagesDiv.scrollHeight, behavior: 'smooth' });
                 }
             }


             function adjustMessageStyle(messageElement) {
                 if (!currentUserID || !messageElement || !messageElement.hasAttribute('data-sender-id')) {
                     return;
                 }

                 const senderId = messageElement.getAttribute('data-sender-id');
                 const senderNameDiv = messageElement.querySelector('.sender-name');

                 messageElement.classList.remove('bg-gray-200', 'self-start', 'bg-blue-100', 'self-end');

                 if (senderId === currentUserID) {
                     messageElement.classList.add('bg-blue-100', 'self-end');
                     if (senderNameDiv) {
                         senderNameDiv.style.display = 'none';
                     }
                 } else {
                     messageElement.classList.add('bg-gray-200', 'self-start');
                     if (senderNameDiv) {
                         senderNameDiv.style.display = 'block';
                     }
                 }
             }

             scrollToBottom();
             if (chatMessagesDiv) {
                 chatMessagesDiv.querySelectorAll('div[data-sender-id]').forEach(adjustMessageStyle);
             }

             const observer = new MutationObserver((mutationsList) => {
                 let needsScroll = false;
                 for (const mutation of mutationsList) {
                     if (mutation.type === 'childList') {
                         mutation.addedNodes.forEach(node => {
                             if (node.nodeType === Node.ELEMENT_NODE) {
                                 if (node.matches && node.matches('div[data-sender-id]')) {
                                     adjustMessageStyle(node);
                                     needsScroll = true;
                                 }
                                 else {
                                     const message = node.querySelector('div[data-sender-id]');
                                     if(message) {
                                         adjustMessageStyle(message);
                                         needsScroll = true;
                                     }
                                 }
                             }
                         });
                     }
                 }
                 if (needsScroll) {
                     scrollToBottom();
                 }
             });

             if (chatMessagesDiv) {
                 observer.observe(chatMessagesDiv, { childList: true, subtree: true });
             }

            if (chatForm) {
                 chatForm.addEventListener('htmx:wsAfterSend', function(evt) {
                    if (messageInput) {
                        messageInput.value = '';
                        messageInput.focus();
                    }
                 });

                 chatForm.addEventListener('htmx:wsError', function(evt) {
                    console.error("WebSocket send error:", evt.detail.error);
                 });
            }
         })();
      </script>
	</section>
}

// templ HomePlaceholder renders a placeholder for the home screen.
templ HomePlaceholder() {
	<div class="p-6">
		<h1 class="text-2xl font-semibold mb-4">Welcome!</h1>
		<p class="text-gray-600">Select a chat room from the sidebar to start messaging.</p>
	</div>
}
